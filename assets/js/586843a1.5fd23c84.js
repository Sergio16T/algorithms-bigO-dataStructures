"use strict";(self.webpackChunkdocumentation=self.webpackChunkdocumentation||[]).push([[323],{3527:e=>{e.exports=JSON.parse('{"version":{"pluginId":"default","version":"current","label":"Next","banner":null,"badge":false,"noIndex":false,"className":"docs-version-current","isLast":true,"docsSidebars":{"studyGuide":[{"type":"link","label":"Study Guide Intro","href":"/algorithms-bigO-dataStructures/docs/intro","docId":"intro","unlisted":false},{"type":"category","label":"Techniques","collapsible":true,"collapsed":true,"items":[{"type":"link","label":"Sliding Window","href":"/algorithms-bigO-dataStructures/docs/techniques/sliding-window","docId":"techniques/sliding-window","unlisted":false},{"type":"link","label":"Two Pointer","href":"/algorithms-bigO-dataStructures/docs/techniques/two-pointer","docId":"techniques/two-pointer","unlisted":false},{"type":"link","label":"Hash Map","href":"/algorithms-bigO-dataStructures/docs/techniques/hash-map","docId":"techniques/hash-map","unlisted":false},{"type":"link","label":"Fast and Slow Pointers","href":"/algorithms-bigO-dataStructures/docs/techniques/fast-and-slow-pointers","docId":"techniques/fast-and-slow-pointers","unlisted":false},{"type":"link","label":"Linked List Traversal","href":"/algorithms-bigO-dataStructures/docs/techniques/linked-list-traversal","docId":"techniques/linked-list-traversal","unlisted":false},{"type":"link","label":"Intervals","href":"/algorithms-bigO-dataStructures/docs/techniques/intervals","docId":"techniques/intervals","unlisted":false},{"type":"link","label":"Breadth First Search Tree Traversal","href":"/algorithms-bigO-dataStructures/docs/techniques/tree-traversal-BFS","docId":"techniques/tree-traversal-BFS","unlisted":false},{"type":"link","label":"Depth First Search Tree Traversal","href":"/algorithms-bigO-dataStructures/docs/techniques/tree-traversal-DFS","docId":"techniques/tree-traversal-DFS","unlisted":false},{"type":"link","label":"Subsets","href":"/algorithms-bigO-dataStructures/docs/techniques/subsets","docId":"techniques/subsets","unlisted":false},{"type":"link","label":"Set","href":"/algorithms-bigO-dataStructures/docs/techniques/set","docId":"techniques/set","unlisted":false},{"type":"link","label":"Dynamic Programming","href":"/algorithms-bigO-dataStructures/docs/techniques/dynamic-programming","docId":"techniques/dynamic-programming","unlisted":false}],"href":"/algorithms-bigO-dataStructures/docs/category/techniques"},{"type":"category","label":"Data Structures","collapsible":true,"collapsed":true,"items":[{"type":"link","label":"Stack","href":"/algorithms-bigO-dataStructures/docs/data-structures/stack","docId":"data-structures/stack","unlisted":false},{"type":"link","label":"Queue","href":"/algorithms-bigO-dataStructures/docs/data-structures/queue","docId":"data-structures/queue","unlisted":false},{"type":"link","label":"Priority Queue","href":"/algorithms-bigO-dataStructures/docs/data-structures/priority-queue","docId":"data-structures/priority-queue","unlisted":false},{"type":"link","label":"Hash Table","href":"/algorithms-bigO-dataStructures/docs/data-structures/hash-table","docId":"data-structures/hash-table","unlisted":false},{"type":"link","label":"Linked List","href":"/algorithms-bigO-dataStructures/docs/data-structures/linked-list","docId":"data-structures/linked-list","unlisted":false},{"type":"link","label":"Doubly Linked List","href":"/algorithms-bigO-dataStructures/docs/data-structures/doubly-linked-list","docId":"data-structures/doubly-linked-list","unlisted":false},{"type":"link","label":"Binary Tree","href":"/algorithms-bigO-dataStructures/docs/data-structures/binary-tree","docId":"data-structures/binary-tree","unlisted":false},{"type":"link","label":"Binary Search Tree","href":"/algorithms-bigO-dataStructures/docs/data-structures/binary-search-tree","docId":"data-structures/binary-search-tree","unlisted":false}],"href":"/algorithms-bigO-dataStructures/docs/category/data-structures"},{"type":"category","label":"Big O Run Time & Space Complexity","collapsible":true,"collapsed":true,"items":[{"type":"link","label":"Recursive Algorithms","href":"/algorithms-bigO-dataStructures/docs/big-o/recursive-algorithms","docId":"big-o/recursive-algorithms","unlisted":false}],"href":"/algorithms-bigO-dataStructures/docs/category/big-o-run-time--space-complexity"}]},"docs":{"big-o/recursive-algorithms":{"id":"big-o/recursive-algorithms","title":"Recursive Algorithms","description":"Understanding Recursive Algorithm Run Time & Space Complexity","sidebar":"studyGuide"},"data-structures/binary-search-tree":{"id":"data-structures/binary-search-tree","title":"Binary Search Tree","description":"","sidebar":"studyGuide"},"data-structures/binary-tree":{"id":"data-structures/binary-tree","title":"Binary Tree","description":"","sidebar":"studyGuide"},"data-structures/doubly-linked-list":{"id":"data-structures/doubly-linked-list","title":"Doubly Linked List","description":"","sidebar":"studyGuide"},"data-structures/hash-table":{"id":"data-structures/hash-table","title":"Hash Table","description":"","sidebar":"studyGuide"},"data-structures/linked-list":{"id":"data-structures/linked-list","title":"Linked List","description":"","sidebar":"studyGuide"},"data-structures/priority-queue":{"id":"data-structures/priority-queue","title":"Priority Queue","description":"","sidebar":"studyGuide"},"data-structures/queue":{"id":"data-structures/queue","title":"Queue","description":"","sidebar":"studyGuide"},"data-structures/stack":{"id":"data-structures/stack","title":"Stack","description":"","sidebar":"studyGuide"},"intro":{"id":"intro","title":"Study Guide Intro","description":"This Study Guide provides an in depth overview of concepts important for DSA.","sidebar":"studyGuide"},"techniques/dynamic-programming":{"id":"techniques/dynamic-programming","title":"Dynamic Programming","description":"","sidebar":"studyGuide"},"techniques/fast-and-slow-pointers":{"id":"techniques/fast-and-slow-pointers","title":"Fast and Slow Pointers","description":"Determing if a linked list has a cycle","sidebar":"studyGuide"},"techniques/hash-map":{"id":"techniques/hash-map","title":"Hash Map","description":"","sidebar":"studyGuide"},"techniques/intervals":{"id":"techniques/intervals","title":"Intervals","description":"","sidebar":"studyGuide"},"techniques/linked-list-traversal":{"id":"techniques/linked-list-traversal","title":"Linked List Traversal","description":"","sidebar":"studyGuide"},"techniques/set":{"id":"techniques/set","title":"Set","description":"","sidebar":"studyGuide"},"techniques/sliding-window":{"id":"techniques/sliding-window","title":"Sliding Window","description":"In many problems dealing with an array (or a LinkedList),","sidebar":"studyGuide"},"techniques/subsets":{"id":"techniques/subsets","title":"Subsets","description":"","sidebar":"studyGuide"},"techniques/tree-traversal-BFS":{"id":"techniques/tree-traversal-BFS","title":"Breadth First Search Tree Traversal","description":"","sidebar":"studyGuide"},"techniques/tree-traversal-DFS":{"id":"techniques/tree-traversal-DFS","title":"Depth First Search Tree Traversal","description":"","sidebar":"studyGuide"},"techniques/two-pointer":{"id":"techniques/two-pointer","title":"Two Pointer","description":"The two-pointer pattern is an efficient technique for solving problems by using two pointers to optimize the traversal and comparison of data, often achieving linear time complexity.","sidebar":"studyGuide"}}}}')}}]);