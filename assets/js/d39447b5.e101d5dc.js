"use strict";(self.webpackChunkdocumentation=self.webpackChunkdocumentation||[]).push([[7727],{6344:(n,e,t)=>{t.r(e),t.d(e,{assets:()=>d,contentTitle:()=>o,default:()=>u,frontMatter:()=>a,metadata:()=>s,toc:()=>l});var i=t(4848),r=t(8453);const a={sidebar_position:1},o="Sliding Window",s={id:"techniques/sliding-window",title:"Sliding Window",description:"In many problems dealing with an array (or a LinkedList),",source:"@site/docs/techniques/sliding-window.md",sourceDirName:"techniques",slug:"/techniques/sliding-window",permalink:"/algorithms-bigO-dataStructures/docs/techniques/sliding-window",draft:!1,unlisted:!1,tags:[],version:"current",sidebarPosition:1,frontMatter:{sidebar_position:1},sidebar:"studyGuide",previous:{title:"Techniques",permalink:"/algorithms-bigO-dataStructures/docs/category/techniques"},next:{title:"Two Pointer",permalink:"/algorithms-bigO-dataStructures/docs/techniques/two-pointer"}},d={},l=[{value:"1. Fixed-Size Window",id:"1-fixed-size-window",level:2},{value:"2. Variable-Size Window",id:"2-variable-size-window",level:2},{value:"3. Sliding Window with Hash Map",id:"3-sliding-window-with-hash-map",level:2},{value:"Summary",id:"summary",level:2}];function c(n){const e={code:"code",h1:"h1",h2:"h2",header:"header",p:"p",pre:"pre",...(0,r.R)(),...n.components};return(0,i.jsxs)(i.Fragment,{children:[(0,i.jsx)(e.header,{children:(0,i.jsx)(e.h1,{id:"sliding-window",children:"Sliding Window"})}),"\n",(0,i.jsx)(e.p,{children:"In many problems dealing with an array (or a LinkedList),\nwe are asked to find or calculate something among all the contiguous subarrays (or sublists)\nof a given size."}),"\n",(0,i.jsx)(e.h2,{id:"1-fixed-size-window",children:"1. Fixed-Size Window"}),"\n",(0,i.jsx)(e.p,{children:"Window is fixed size and we contract by removing first element from window as we add the current element in iteration"}),"\n",(0,i.jsx)(e.p,{children:"Problem: Find the maximum sum of any contiguous subarray of size k."}),"\n",(0,i.jsx)(e.p,{children:"Strategy: One common pattern is to iterate through the array while doing calculations within a fixed window/range"}),"\n",(0,i.jsx)(e.pre,{children:(0,i.jsx)(e.code,{className:"language-JavaScript",children:'const maximumSumSubArray = (arr, k) =>  {\n  //length of array must be greater than k\n  if (arr.length < k) {\n    console.log("Invalid")\n    return -1;\n  }\n\n  // Compute sum of first window of size k\n  let max_sum = 0;\n  for (let i = 0; i < k; i++) {\n    max_sum += arr[i];\n  }\n  // Compute sums of remaining windows by removing first element of previous window and adding last element of current window.\n  let window_sum = max_sum;\n  for (let j = k; j < arr.length; j++) {\n    // arr[j] last element of current window\n    // arr[j - k] first element of previous window\n    window_sum += arr[j] - arr[j - k];\n    max_sum = Math.max(max_sum, window_sum);\n  }\n\n  return max_sum;\n}\n'})}),"\n",(0,i.jsx)(e.p,{children:"Another strategy is to iterate through the elements one by one, iterating at most k times for each index where k is the size of window"}),"\n",(0,i.jsx)(e.pre,{children:(0,i.jsx)(e.code,{className:"language-JavaScript",children:"var strStr = function(haystack, needle) {\n  const lengthOfWindow = needle.length; // n\n  const h = haystack.length;\n\n  for (let windowStart = 0; windowStart <= h - lengthOfWindow; windowStart++) {\n    // at each window iterate through the length of needle to see if there is a match;\n    for (let i = 0; i < lengthOfWindow; i++) {\n      // compare each char in the window of haystack against the needle\n      if (haystack[windowStart + i] != needle[i]) {\n        // break the loop if not equal and window will move\n        break;\n      }\n      if (i === lengthOfWindow - 1) {\n        return windowStart;\n      }\n    }\n  }\n  return -1;\n};\n"})}),"\n",(0,i.jsx)(e.h2,{id:"2-variable-size-window",children:"2. Variable-Size Window"}),"\n",(0,i.jsx)(e.p,{children:"Size of window contracts as needed as we iterate through the elements"}),"\n",(0,i.jsx)(e.p,{children:"Often times with variable size windows we are looking for a min or max window that meets certain criteria\nwithin a subset of elements"}),"\n",(0,i.jsx)(e.p,{children:"Example: Length of longest substring without repeating characters"}),"\n",(0,i.jsx)(e.pre,{children:(0,i.jsx)(e.code,{className:"language-JavaScript",children:'var lengthOfLongestSubstring = function(s) {\n  const set = new Set();\n  let left = 0,\n    right= 0,\n    maxWindow = 0;\n\n  while (right < s.length) {\n    // "abcabcbb"\n    const char = s[right]; // right pointer iterates\n    if (set.has(char)) {\n      set.delete(s[left]);\n      left++;\n    } else {\n      set.add(char);\n      right++;\n      maxWindow = Math.max(set.size, maxWindow);\n    }\n  }\n  return maxWindow;\n\n}\n'})}),"\n",(0,i.jsx)(e.p,{children:"Example: Length of longest increasing contiguous array"}),"\n",(0,i.jsx)(e.pre,{children:(0,i.jsx)(e.code,{className:"language-JavaScript",children:"// length of longest increasing subarray\nvar lengthOfLIS = function(nums) {\n  // use sliding window and move through the entire array.\n  let windowStart = 0,\n    windowEnd = 0,\n    largestWindow = 0;\n\n  // ONE PASS\n  // as I move from left to right check if value is increasing. and keep a counter via largest window.\n\n  for (let i = 0; i < nums.length; i++) {\n    const n = nums[i];\n    if (nums[i + 1] > n) {\n      windowEnd = i + 1;\n      largestWindow = Math.max(largestWindow, (windowEnd - windowStart) + 1);\n    } else {\n      windowStart = i + 1;\n    }\n  }\n  return largestWindow;\n};\n"})}),"\n",(0,i.jsx)(e.h2,{id:"3-sliding-window-with-hash-map",children:"3. Sliding Window with Hash Map"}),"\n",(0,i.jsx)(e.pre,{children:(0,i.jsx)(e.code,{className:"language-JavaScript",children:"var lengthOfLongestSubstringKDistinct = function(s, k) {\n  /* build a hashmap to keep track unique characters and counts\n    contract window once k distinct characters has been exceeded\n    keep track of length as max\n  */\n  let max = 0;\n  const map = new Map();\n\n  let left = 0;\n  for (let right = 0; right < s.length; right++) {\n    // update map\n    const ch = s[right];\n    map.set(ch, map.get(ch) ? map.get(ch) + 1 : 1);\n\n    // check for out of bounds distinct characters\n    while (map.size > k) {\n      // contract the window\n      // update key count for char at s[left]\n      map.set(s[left], map.get(s[left]) - 1);\n      // remove key if count is 0\n      if (map.get(s[left]) === 0) {\n        map.delete(s[left]);\n      }\n      left++;\n    }\n    max = Math.max(max, right - left + 1);\n  }\n\n  return max;\n};\n"})}),"\n",(0,i.jsx)(e.h2,{id:"summary",children:"Summary"}),"\n",(0,i.jsx)(e.p,{children:"In many problems dealing with an array (or a LinkedList),\nwe are asked to find or calculate something among all the contiguous subarrays (or sublists)\nof a given size. For example, take a look at this problem:"}),"\n",(0,i.jsx)(e.p,{children:"A brute force solution would require revisiting previously visited elements e.g. in a nested loop."}),"\n",(0,i.jsx)(e.p,{children:"With sliding window we can improve run time to O(n) by avoiding revisiting elements and instead moving the window over and updating as needed."}),"\n",(0,i.jsx)(e.pre,{children:(0,i.jsx)(e.code,{className:"language-java",children:"import java.util.Arrays;\n\nclass AverageOfSubarrayOfSizeK {\n    public static double[] bruteForce(int K, int[] arr) {\n        double[] result = new double[arr.length - K + 1];\n        for (int i = 0; i <= arr.length - K; i++) {\n          // find sum of next 'K' elements\n          double sum = 0;\n          for (int j = i; j < i + K; j++)\n              sum += arr[j];\n          result[i] = sum / K; // calculate average\n        }\n\n        return result;\n    }\n\n\n    public static double[] findAverages(int K, int[] arr) {\n        double[] result = new double[arr.length - K + 1];\n        double windowSum = 0;\n        int windowStart = 0;\n        for (int windowEnd = 0; windowEnd < arr.length; windowEnd++) {\n          windowSum += arr[windowEnd]; // add the next element\n          // slide the window, we don't need to slide if we've not hit the required window size of 'k'\n          if (windowEnd >= K - 1) {\n              result[windowStart] = windowSum / K; // calculate the average\n              windowSum -= arr[windowStart]; // subtract the element going out\n              windowStart++; // slide the window ahead\n          }\n        }\n\n        return result;\n    }\n\n  public static void main(String[] args) {\n    double[] bfResult = AverageOfSubarrayOfSizeK.bruteForce(5, new int[] { 1, 3, 2, 6, -1, 4, 1, 8, 2 });\n    System.out.println(\"Averages of subarrays of size K: \" + Arrays.toString(bfResult));\n\n    double[] result = AverageOfSubarrayOfSizeK.findAverages(5, new int[] { 1, 3, 2, 6, -1, 4, 1, 8, 2 });\n    System.out.println(\"Averages of subarrays of size K: \" + Arrays.toString(result));\n  }\n}\n\n"})})]})}function u(n={}){const{wrapper:e}={...(0,r.R)(),...n.components};return e?(0,i.jsx)(e,{...n,children:(0,i.jsx)(c,{...n})}):c(n)}},8453:(n,e,t)=>{t.d(e,{R:()=>o,x:()=>s});var i=t(6540);const r={},a=i.createContext(r);function o(n){const e=i.useContext(a);return i.useMemo((function(){return"function"==typeof n?n(e):{...e,...n}}),[e,n])}function s(n){let e;return e=n.disableParentContext?"function"==typeof n.components?n.components(r):n.components||r:o(n.components),i.createElement(a.Provider,{value:e},n.children)}}}]);