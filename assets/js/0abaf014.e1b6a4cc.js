"use strict";(self.webpackChunkdocumentation=self.webpackChunkdocumentation||[]).push([[7480],{787:(e,n,r)=>{r.r(n),r.d(n,{assets:()=>l,contentTitle:()=>s,default:()=>c,frontMatter:()=>o,metadata:()=>a,toc:()=>h});var t=r(4848),i=r(8453);const o={sidebar_position:2},s="Two Pointer",a={id:"techniques/two-pointer",title:"Two Pointer",description:"The two-pointer pattern is an efficient technique for solving problems by using two pointers to optimize the traversal and comparison of data, often achieving linear time complexity.",source:"@site/docs/techniques/two-pointer.md",sourceDirName:"techniques",slug:"/techniques/two-pointer",permalink:"/algorithms-bigO-dataStructures/docs/techniques/two-pointer",draft:!1,unlisted:!1,tags:[],version:"current",sidebarPosition:2,frontMatter:{sidebar_position:2},sidebar:"studyGuide",previous:{title:"Sliding Window",permalink:"/algorithms-bigO-dataStructures/docs/techniques/sliding-window"},next:{title:"Hash Map",permalink:"/algorithms-bigO-dataStructures/docs/techniques/hash-map"}},l={},h=[{value:"1. Approaching Pointers",id:"1-approaching-pointers",level:2},{value:"2. Traversing Two Arrays to Compare or Merge elements",id:"2-traversing-two-arrays-to-compare-or-merge-elements",level:2},{value:"3. Sliding Window",id:"3-sliding-window",level:2},{value:"4. Partitioning",id:"4-partitioning",level:2},{value:"5. Fast and slow pointers",id:"5-fast-and-slow-pointers",level:2},{value:"6. Three Pointer",id:"6-three-pointer",level:2},{value:"Summary",id:"summary",level:2}];function d(e){const n={a:"a",code:"code",h1:"h1",h2:"h2",header:"header",li:"li",ol:"ol",p:"p",pre:"pre",ul:"ul",...(0,i.R)(),...e.components};return(0,t.jsxs)(t.Fragment,{children:[(0,t.jsx)(n.header,{children:(0,t.jsx)(n.h1,{id:"two-pointer",children:"Two Pointer"})}),"\n",(0,t.jsx)(n.p,{children:"The two-pointer pattern is an efficient technique for solving problems by using two pointers to optimize the traversal and comparison of data, often achieving linear time complexity."}),"\n",(0,t.jsx)(n.p,{children:"By adjusting pointer movement, this pattern simplifies complex problems involving pairs, subsequences, or specific conditions."}),"\n",(0,t.jsx)(n.h2,{id:"1-approaching-pointers",children:"1. Approaching Pointers"}),"\n",(0,t.jsx)(n.p,{children:"Strategy: Approaching Pointers from both ends of sorted array looking for indices of values whose sum is equal to target"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-JavaScript",children:"function twoSumSorted(arr, target) {\n    let left = 0;\n    let right = arr.length - 1;\n    while (left < right) {\n        const sum = arr[left] + arr[right];\n        if (sum === target) {\n          return new Array(left, right);\n        }\n        if (sum < target) {\n          left++;\n        } else {\n          right--;\n        }\n    }\n    return null; // No pair found\n}\n"})}),"\n",(0,t.jsx)(n.h2,{id:"2-traversing-two-arrays-to-compare-or-merge-elements",children:"2. Traversing Two Arrays to Compare or Merge elements"}),"\n",(0,t.jsx)(n.p,{children:"Comparing Two Sequences uses two pointers to traverse two sequences (arrays or strings) simultaneously, often to check if elements in one sequence follow the same order in the other."}),"\n",(0,t.jsx)(n.p,{children:"Common Use Cases:"}),"\n",(0,t.jsxs)(n.ol,{children:["\n",(0,t.jsx)(n.li,{children:"Checking if one string is a subsequence of another."}),"\n",(0,t.jsx)(n.li,{children:"Merging two sequences."}),"\n",(0,t.jsx)(n.li,{children:"Finding the intersection of two sorted arrays."}),"\n"]}),"\n",(0,t.jsx)(n.p,{children:"Example checking if one string is a subsequence of another"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-JavaScript",children:"var isSubsequence = function(s, t) {\n  /* Two pointers:\n    if the first pointer is equal to the length of s then we have found all characters\n    in target string and s is a subsequence of t\n  */\n  let p1 = 0; // p1 is for iterating through source string\n  let p2 = 0; // p2 is for iterating through the target string\n\n  // iterate as long as p1 is within the bounds of source string\n  // and p2 is within the bounds of target string\n  while (p1 < s.length && p2 < t.length)  {\n    if (s[p1] === t[p2]) {\n      p1++;\n    }\n    p2++;\n  }\n  return p1 === s.length;\n\n};\n"})}),"\n",(0,t.jsx)(n.p,{children:"Example: Merging strings alternately"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-JavaScript",children:'var mergeAlternately = function(word1, word2) {\n  // abcd QQQQJJJJ aQbQcQdQ\n  let merged = "";\n  // pointers;\n  let i = 0, // store pointer for word1.\n    j = 0; // store pointer for word2\n\n  while (i < word1.length || j < word2.length) {\n    if (i < word1.length) {\n      merged += word1[i];\n      i++;\n    }\n    if (j < word2.length) {\n      merged += word2[j];\n      j++;\n    }\n  }\n  return merged;\n};\n'})}),"\n",(0,t.jsx)(n.h2,{id:"3-sliding-window",children:"3. Sliding Window"}),"\n",(0,t.jsxs)(n.p,{children:["Sliding window is a substantial sub-pattern. Read more ",(0,t.jsx)(n.a,{href:"/docs/techniques/sliding-window",children:"here"})]}),"\n",(0,t.jsx)(n.h2,{id:"4-partitioning",children:"4. Partitioning"}),"\n",(0,t.jsx)(n.p,{children:"Use two pointers to partition an array into segments. Used to solve problems that involve partitioning arrays into different regions."}),"\n",(0,t.jsx)(n.p,{children:"For these questions, each pointer represents where the next element belonging to that region should go."}),"\n",(0,t.jsx)(n.p,{children:"Example: Given an array A[] consisting of only 0s, 1s, and 2s.\nThe task is to sort the array, i.e., put all 0s first, then all 1s and all 2s in last."}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-JavaScript",children:"function dutchNationalFlag(arr) {\n  let low = 0;\n  let mid = 0;\n  let high = arr.length - 1;\n\n  while (mid <= high) {\n    switch (arr[mid]) {\n      case 0:\n        [arr[low], arr[mid]] = [arr[mid], arr[low]];\n        low++;\n        mid++;\n        break;\n      case 1:\n        mid++;\n        break;\n      case 2:\n        [arr[mid], arr[high]] = [arr[high], arr[mid]];\n        high--;\n        break;\n    }\n  }\n}\n"})}),"\n",(0,t.jsx)(n.p,{children:"Example: Two Pointer Quick Sort"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-JavaScript",children:"function quickSort(arr, low = 0, high = arr.length - 1) {\n    if (low < high) {\n        const pivotIndex = partition(arr, low, high);\n        quickSort(arr, low, pivotIndex - 1);\n        quickSort(arr, pivotIndex + 1, high);\n    }\n    return arr;\n}\n\nfunction partition(arr, low, high) {\n    const pivot = arr[high];\n    let left = low;\n    let right = high - 1;\n\n    while (left <= right) {\n        while (left <= right && arr[left] < pivot) {\n            left++;\n        }\n        while (left <= right && arr[right] > pivot) {\n            right--;\n        }\n        if (left <= right) {\n            [arr[left], arr[right]] = [arr[right], arr[left]];\n            left++;\n            right--;\n        }\n    }\n    [arr[left], arr[high]] = [arr[high], arr[left]];\n    return left;\n}\n"})}),"\n",(0,t.jsx)(n.p,{children:"Example: Given an array of integers, rearrange the array so that all odd numbers appear before all even numbers."}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-JavaScript",children:"function partitionOddEven(arr) {\n  let left = 0;\n  let right = arr.length - 1;\n\n  while (left < right) {\n    // Move the left pointer until we find an even number\n    while (left < right && arr[left] % 2 !== 0) {\n      left++;\n    }\n    // Move the right pointer until we find an odd number\n    while (left < right && arr[right] % 2 === 0) {\n      right--;\n    }\n    // Swap the even number on the left with the odd number on the right\n    if (left < right) {\n      [arr[left], arr[right]] = [arr[right], arr[left]];\n      left++;\n      right--;\n    }\n  }\n}\n"})}),"\n",(0,t.jsx)(n.h2,{id:"5-fast-and-slow-pointers",children:"5. Fast and slow pointers"}),"\n",(0,t.jsxs)(n.p,{children:["Fast and slow pointers is a substantial sub-pattern. Read more ",(0,t.jsx)(n.a,{href:"/docs/techniques/fast-and-slow-pointers",children:"here"})]}),"\n",(0,t.jsx)(n.h2,{id:"6-three-pointer",children:"6. Three Pointer"}),"\n",(0,t.jsx)(n.p,{children:"The three pointer pattern is an extension of two pointer pattern"}),"\n",(0,t.jsx)(n.h2,{id:"summary",children:"Summary"}),"\n",(0,t.jsx)(n.p,{children:"Choosing the Right Pattern"}),"\n",(0,t.jsx)(n.p,{children:"The choice of two-pointer pattern depends on the problem\u2019s requirements, such as:"}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsx)(n.li,{children:"Whether the data is sorted or needs sorting."}),"\n",(0,t.jsx)(n.li,{children:"Whether you are looking for pairs, subsequences, or specific properties."}),"\n",(0,t.jsx)(n.li,{children:"Whether you need to iterate over one or two sequences."}),"\n"]}),"\n",(0,t.jsx)(n.p,{children:"Each pattern leverages the efficiency of two-pointer movement to optimize the traversal and comparison of data, often resulting in linear time complexity solutions to problems that might otherwise require more complex approaches."})]})}function c(e={}){const{wrapper:n}={...(0,i.R)(),...e.components};return n?(0,t.jsx)(n,{...e,children:(0,t.jsx)(d,{...e})}):d(e)}},8453:(e,n,r)=>{r.d(n,{R:()=>s,x:()=>a});var t=r(6540);const i={},o=t.createContext(i);function s(e){const n=t.useContext(o);return t.useMemo((function(){return"function"==typeof e?e(n):{...n,...e}}),[n,e])}function a(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(i):e.components||i:s(e.components),t.createElement(o.Provider,{value:n},e.children)}}}]);